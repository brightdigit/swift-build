# Swift - Build and Test GitHub Action
#
# A comprehensive GitHub Action for building and testing Swift packages across multiple platforms.
# Provides intelligent caching, multi-platform support, and optimized workflows for both
# Swift Package Manager (SPM) and Xcode-based builds.
#
# Key Features:
# - Multi-platform support: Ubuntu (Swift 5.9-6.2), macOS (Xcode 15.1+), and Windows (Swift 6.1+)
# - Intelligent caching: Platform-specific strategies for optimal performance
# - Apple platform testing: iOS, watchOS, tvOS, visionOS, macOS with simulator support
# - Automatic platform downloads for missing Apple platforms
# - Windows Swift toolchain installation and configuration
# - Optimized for GitHub Actions with >85% cache hit rates
#
# Advantages over alternatives:
# - More comprehensive than swift-actions/setup-swift
# - Better caching strategies than manual xcodebuild scripts
# - Built-in multi-platform matrix support
# - Handles complex Xcode/simulator configurations automatically
#
# Supported Platforms:
# - Ubuntu: focal/jammy/noble with Swift 5.9, 6.0, 6.1, 6.2
# - macOS: Xcode 15.1+ with full Apple platform ecosystem support
# - Windows: windows-2022/windows-2025 with Swift 6.1+ via compnerd/gha-setup-swift

name: 'Swift - Build and Test'
description: 'Builds and tests a Swift package on the current platform'

# Marketplace metadata
branding:
  icon: 'package'  # Code/development icon
  color: 'orange'  # Swift's signature orange color

inputs:
  # The directory containing your Swift package (Package.swift file)
  # Examples: '.', 'MyPackage/', 'Sources/MyLibrary'
  # Default: '.' (current directory)
  working-directory:
    description: 'Directory containing the Swift package'
    required: false
    default: '.'

  # The scheme name to build and test (REQUIRED)
  # Must match a scheme defined in your Package.swift or .xcodeproj
  # Examples: 'MyPackage', 'MyLibrary', 'MyApp-iOS'
  scheme:
    description: 'The scheme to build and test'
    required: true

  # Apple platform type for simulator/device testing
  # Valid values: 'ios', 'watchos', 'visionos', 'tvos', 'macos'
  # Omit this parameter for cross-platform SPM builds
  # Required when using deviceName/osVersion parameters
  type:
    description: 'Build type for Apple platforms (ios, watchos, visionos, tvos, macos)'
    required: false

  # Path to specific Xcode installation for macOS builds
  # Examples: '/Applications/Xcode_15.1.app', '/Applications/Xcode_16.0.app'
  # Default: Uses system default Xcode when omitted
  # Only used on macOS runners with type parameter
  xcode:
    description: 'Xcode version path for Apple platforms'
    required: false

  # Simulator device name for Apple platform testing
  # Examples: 'iPhone 15', 'Apple Watch Series 9 (45mm)', 'Apple TV 4K (3rd generation)'
  # Must be used together with osVersion parameter
  # Only valid when type parameter is specified
  deviceName:
    description: 'Simulator device name for Apple platforms'
    required: false

  # Simulator OS version for Apple platform testing
  # Examples: '17.0', '10.0', '17.0' (iOS), '7.0' (watchOS), '17.0' (tvOS)
  # Must be used together with deviceName parameter
  # Version must be available for the specified platform type
  osVersion:
    description: 'Simulator OS version for Apple platforms'
    required: false

  # Automatically download missing Apple platforms via xcodebuild
  # Set to 'true' to download iOS, watchOS, tvOS, or visionOS if not installed
  # Only applies to Apple platform builds (when type is specified)
  # Default: 'false' (fails if platform missing)
  download-platform:
    description: 'Whether to download the platform if not available'
    required: false
    default: 'false'

  # Windows Swift toolchain version for Windows runners
  # Examples: 'swift-6.2-branch', 'swift-6.1-release', 'swift-6.0-release'
  # Only used on Windows runners to install specific Swift toolchain
  # Requires windows-swift-build parameter to be specified
  # Maps to 'swift-version' parameter in compnerd/gha-setup-swift
  windows-swift-version:
    description: 'Swift version for Windows Swift toolchain installation'
    required: false

  # Windows Swift build identifier for Windows runners
  # Examples: '6.2-DEVELOPMENT-SNAPSHOT-2025-09-06-a', '6.1-RELEASE'
  # Only used on Windows runners with windows-swift-version parameter
  # Must match available builds for the specified swift-version
  # Maps to 'swift-build' parameter in compnerd/gha-setup-swift
  windows-swift-build:
    description: 'Swift build identifier for Windows Swift toolchain installation'
    required: false

  # Enable xcbeautify for prettified xcodebuild output
  # When enabled, installs and uses xcbeautify to format xcodebuild output
  # Provides human-friendly, colored output and better CI integration
  # Only applies to Apple platform builds (when type parameter is specified)
  # Default: 'false' (disabled)
  use-xcbeautify:
    description: 'Enable xcbeautify for prettified xcodebuild output (Apple platforms only)'
    required: false
    default: 'false'

  # xcbeautify renderer for CI integration
  # Options: 'default', 'github-actions', 'teamcity', 'azure-devops-pipelines'
  # 'github-actions': Highlights warnings/errors in GitHub Actions UI
  # 'teamcity': Uses TeamCity service messages for better integration
  # 'azure-devops-pipelines': Uses Azure DevOps logging commands
  # Only used when use-xcbeautify is 'true' and type parameter is specified
  xcbeautify-renderer:
    description: 'xcbeautify renderer for CI integration (default, github-actions, teamcity, azure-devops-pipelines)'
    required: false
    default: 'default'

  # xcbeautify version to install
  # Specifies which version of xcbeautify to download and install
  # Examples: '2.30.1', '2.29.0', '2.28.0'
  # Only used when use-xcbeautify is 'true' and type parameter is specified
  # Default: '2.30.1' (latest stable version)
  xcbeautify-version:
    description: 'xcbeautify version to install (e.g., 2.30.1, 2.29.0)'
    required: false
    default: '2.30.1'

  # Skip Package.resolved dependency pinning
  # Controls strict dependency pinning behavior in Swift Package Manager builds
  #
  # When 'false' (default - strict mode):
  # - Requires Package.resolved to exist (build fails if missing)
  # - Always uses --force-resolved-versions flag for reproducible builds
  # - Cache keys include Package.resolved hash
  #
  # When 'true' (floating dependencies mode):
  # - Package.resolved is optional (build succeeds even if missing)
  # - Omits --force-resolved-versions flag to allow latest dependency versions
  # - Cache keys use 'no-resolved' instead of hash
  #
  # Use 'true' for packages without Package.resolved or when testing against latest dependencies
  # Default: 'false'
  skip-package-resolved:
    description: 'Skip Package.resolved dependency pinning (allows floating dependency versions)'
    required: false
    default: 'false'

runs:
  using: "composite"
  steps:
    # OS Detection and Environment Setup
    # This step determines the build strategy based on the GitHub runner operating system.
    # macOS runners: Enable Xcode-based builds with derived data caching for Apple platforms
    # Ubuntu runners: Use Swift Package Manager with standard .build directory caching
    # Windows runners: Use Swift Package Manager with Windows-specific toolchain support
    # The DERIVED_DATA_PATH environment variable optimizes Xcode build performance and caching
    - name: Detect OS
      shell: bash
      id: detect-os
      working-directory: ${{ inputs.working-directory }}
      run: |
        if [[ "$RUNNER_OS" == "macOS" ]]; then
          # macOS runners support both SPM and Xcode builds
          # Set up derived data path for optimal Xcode build performance and caching
          echo "os=macos" >> $GITHUB_OUTPUT
          echo "DERIVED_DATA_PATH=$RUNNER_TEMP/DerivedData" >> $GITHUB_ENV
        elif [[ "$RUNNER_OS" == "Windows" ]]; then
          # Windows runners support SPM builds with custom Swift toolchain installation
          # Will use Swift Package Manager with Windows-specific caching strategies
          echo "os=windows" >> $GITHUB_OUTPUT
        elif [[ "$RUNNER_OS" == "Linux" ]]; then
          # Ubuntu runners only support SPM builds (no Xcode available)
          # Will use standard Swift Package Manager build and cache directories
          echo "os=ubuntu" >> $GITHUB_OUTPUT
        else
          echo "Unsupported operating system: $RUNNER_OS" >&2
          exit 1
        fi

    # Package.resolved Detection and Hash Computation
    # This step determines whether to use Package.resolved for dependency pinning
    # and computes a cache key component that's consistent across all caching strategies.
    #
    # Decision Logic:
    # - If skip-package-resolved is 'true': Use 'no-resolved' (floating dependencies allowed)
    # - If skip-package-resolved is 'false' AND Package.resolved missing: FAIL (strict mode)
    # - Otherwise: Use actual file hash (pinned dependencies)
    #
    # Outputs:
    # - resolved-hash: The hash to use in cache keys ('no-resolved' or actual hash)
    # - use-resolved: 'true' if using Package.resolved, 'false' otherwise
    #
    # This centralized approach ensures consistent cache behavior and prevents
    # empty hash strings when Package.resolved is missing
    - name: Detect Package.resolved
      shell: bash
      id: detect-resolved
      working-directory: ${{ inputs.working-directory }}
      run: |
        if [[ "${{ inputs.skip-package-resolved }}" == "true" ]]; then
          # User explicitly requested to skip Package.resolved
          echo "resolved-hash=no-resolved" >> $GITHUB_OUTPUT
          echo "use-resolved=false" >> $GITHUB_OUTPUT
          echo "Skipping Package.resolved (skip-package-resolved=true)"
        elif [[ ! -f "Package.resolved" ]]; then
          # Package.resolved file doesn't exist but is required (strict mode)
          echo "ERROR: Package.resolved not found and skip-package-resolved is false" >&2
          echo "Either add Package.resolved to your repository or set skip-package-resolved: true" >&2
          exit 1
        else
          # Package.resolved exists and should be used
          # Compute hash for cache key using portable method
          if command -v shasum >/dev/null 2>&1; then
            RESOLVED_HASH=$(shasum -a 256 Package.resolved | cut -d' ' -f1)
          elif command -v sha256sum >/dev/null 2>&1; then
            RESOLVED_HASH=$(sha256sum Package.resolved | cut -d' ' -f1)
          else
            # Fallback: use file size and modification time as pseudo-hash
            RESOLVED_HASH=$(ls -l Package.resolved | awk '{print $5"-"$6"-"$7"-"$8}')
          fi
          echo "resolved-hash=$RESOLVED_HASH" >> $GITHUB_OUTPUT
          echo "use-resolved=true" >> $GITHUB_OUTPUT
          echo "Using Package.resolved with hash: $RESOLVED_HASH"
        fi

    # macOS Xcode Configuration Steps
    # These steps only execute on macOS runners when Apple platform builds are requested.
    # They configure the Xcode toolchain, map platform types to SDK/simulator names,
    # and optionally download missing Apple platforms.

    # Configure the Xcode developer directory for the build environment
    # Sets DEVELOPER_DIR to point to the specific Xcode installation's Developer directory
    # This ensures all Xcode tools (xcodebuild, xcrun, etc.) use the correct toolchain
    # Essential for environments with multiple Xcode versions installed
    - name: Setup Xcode
      if: steps.detect-os.outputs.os == 'macos' && inputs.xcode
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: echo "DEVELOPER_DIR=${{ inputs.xcode }}/Contents/Developer" >> $GITHUB_ENV

    # Get Xcode version from the actual Xcode installation being used
    # This ensures accurate version detection regardless of path format
    # Uses DEVELOPER_DIR when available, falls back to system default
    # The DEVELOPER_DIR environment variable ensures xcodebuild uses the correct Xcode
    - name: Set Xcode Version
      if: steps.detect-os.outputs.os == 'macos'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        # Get Xcode version from the actual installation
        # This works for both custom Xcode paths and system default
        # DEVELOPER_DIR is set above if a custom Xcode path was provided
        
        # Check if xcodebuild exists and is accessible
        if ! command -v xcodebuild >/dev/null 2>&1; then
          echo "Error: xcodebuild command not found in PATH" >&2
          exit 0
        fi
        
        # Method 1: Try xcodebuild command
        if XCODE_VERSION=$(timeout 30 xcodebuild -version 2>&1 | head -1 | cut -d' ' -f2); then
          echo "XCODE_NAME=$XCODE_VERSION" >> $GITHUB_ENV
        else
          # Method 2: Try to read from Xcode Info.plist
          if [ -n "${{ inputs.xcode }}" ] && [ -f "${{ inputs.xcode }}/Contents/Info.plist" ]; then
            if XCODE_VERSION=$(defaults read "${{ inputs.xcode }}/Contents/Info.plist" CFBundleShortVersionString 2>/dev/null); then
              echo "XCODE_NAME=$XCODE_VERSION" >> $GITHUB_ENV
            fi
          else
            # Method 3: Try system default Xcode
            if [ -f "/Applications/Xcode.app/Contents/Info.plist" ]; then
              if XCODE_VERSION=$(defaults read "/Applications/Xcode.app/Contents/Info.plist" CFBundleShortVersionString 2>/dev/null); then
                echo "XCODE_NAME=$XCODE_VERSION" >> $GITHUB_ENV
              fi
            fi
          fi
        fi

    # Map platform type parameter to Xcode SDK and platform destination strings
    # This critical step translates user-friendly type inputs into the specific
    # SDK and platform identifiers required by xcodebuild commands.
    #
    # Platform Mapping Logic:
    # - 'ios' → SDK='iphonesimulator', PLATFORM='iOS Simulator'
    # - 'watchos' → SDK='watchsimulator', PLATFORM='watchOS Simulator'
    # - 'visionos' → SDK='xrsimulator', PLATFORM='visionOS Simulator'
    # - 'tvos' → SDK='appletvsimulator', PLATFORM='tvOS Simulator'
    # - 'macos' → SDK='macosx', PLATFORM='macOS' (no simulator, native)
    #
    # These environment variables are used later in xcodebuild destination strings
    # and -sdk parameters to target the correct platform for testing
    - name: Set SDK and Platform
      if: steps.detect-os.outputs.os == 'macos' && inputs.type
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        case ${{ inputs.type }} in
          ios)
            echo "PLATFORM=iOS Simulator" >> $GITHUB_ENV
            echo "SDK=iphonesimulator" >> $GITHUB_ENV
            ;;
          watchos)
            echo "PLATFORM=watchOS Simulator" >> $GITHUB_ENV
            echo "SDK=watchsimulator" >> $GITHUB_ENV
            ;;
          visionos)
            echo "PLATFORM=visionOS Simulator" >> $GITHUB_ENV
            echo "SDK=xrsimulator" >> $GITHUB_ENV
            ;;
          tvos)
            echo "PLATFORM=tvOS Simulator" >> $GITHUB_ENV
            echo "SDK=appletvsimulator" >> $GITHUB_ENV
            ;;
          macos)
            echo "PLATFORM=macOS" >> $GITHUB_ENV
            echo "SDK=macosx" >> $GITHUB_ENV
            ;;
        esac

    # Automatically download missing Apple platform support (optional)
    # This step executes only when download-platform is set to 'true' and runs
    # xcodebuild -downloadPlatform to install missing platform SDKs and simulators.
    #
    # Platform Download Behavior:
    # - Downloads the complete platform SDK and simulator runtime
    # - Only downloads if the platform is not already installed
    # - macOS platform is always available (no download needed)
    # - Requires internet connectivity and may take several minutes
    # - Fails gracefully if download is unsuccessful
    #
    # Use Cases:
    # - Fresh GitHub runners missing specific platform support
    # - Custom Xcode installations with limited platform coverage
    # - Ensuring consistent platform availability across different runner configurations
    #
    # Performance Impact: First-time downloads can add 5-15 minutes to workflow runtime
    # but subsequent builds benefit from pre-installed platforms
    - name: Download Platform
      if: steps.detect-os.outputs.os == 'macos' && inputs.type && inputs.type != 'macos' && inputs.download-platform == 'true'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        # Fix for iOS simulator connection issue (https://github.com/actions/runner-images/issues/12862)
        # Establish simulator connection before running xcodebuild
        xcrun simctl list > /dev/null
        case ${{ inputs.type }} in
          ios)
            xcodebuild -downloadPlatform iOS
            ;;
          watchos)
            xcodebuild -downloadPlatform watchOS
            ;;
          visionos)
            xcodebuild -downloadPlatform visionOS
            ;;
          tvos)
            xcodebuild -downloadPlatform tvOS
            ;;
        esac

    # Windows Swift Toolchain Installation
    # This step only executes on Windows runners when windows-swift-version is provided.
    # Uses the compnerd/gha-setup-swift action to install the specified Swift toolchain.
    # See: https://github.com/compnerd/gha-setup-swift for detailed parameter documentation
    #
    # Installation Process:
    # - Downloads and installs the specified Swift toolchain version
    # - Configures the Windows environment for Swift development
    # - Sets up necessary paths and environment variables
    #
    # Parameter Mapping:
    # - windows-swift-version → swift-version (e.g., swift-6.2-branch, swift-6.1-release)
    # - windows-swift-build → swift-build (e.g., 6.2-DEVELOPMENT-SNAPSHOT-2025-09-06-a, 6.1-RELEASE)
    #
    # This enables Swift development on Windows runners with the exact toolchain
    # version required for your project, ensuring consistency across different environments.
    - name: Install Windows Swift toolchain
      if: steps.detect-os.outputs.os == 'windows' && inputs.windows-swift-version
      uses: compnerd/gha-setup-swift@main
      with:
        swift-version: ${{ inputs.windows-swift-version }}
        swift-build: ${{ inputs.windows-swift-build }}

    # xcbeautify Installation
    # Installs xcbeautify tool for prettified xcodebuild output when enabled.
    # xcbeautify is a Swift-based alternative to xcpretty that provides:
    # - Human-friendly and colored output for xcodebuild commands
    # - Support for new build system output and parallel testing
    # - GitHub Actions, TeamCity, and Azure DevOps integration
    # - Better CI output formatting and error highlighting
    #
    # Installation Methods:
    # - macOS: Downloads pre-built binary from GitHub releases with caching
    # - Version controlled via xcbeautify-version input parameter
    #
    # Only installs when use-xcbeautify input is set to 'true' AND
    # when building Apple platforms (type parameter is specified)
    - name: Cache xcbeautify
      if: steps.detect-os.outputs.os == 'macos' && inputs.use-xcbeautify == 'true' && inputs.type
      uses: actions/cache@v4
      with:
        path: ${{ runner.temp }}/xcbeautify
        key: xcbeautify-${{ inputs.xcbeautify-version }}
        restore-keys: |
          xcbeautify-

    - name: Install xcbeautify
      if: steps.detect-os.outputs.os == 'macos' && inputs.use-xcbeautify == 'true' && inputs.type
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        # Create local installation directory
        XCBEAUTIFY_DIR="$RUNNER_TEMP/xcbeautify"
        
        # Check if xcbeautify is already cached and working
        if [ -f "$XCBEAUTIFY_DIR/xcbeautify" ] && "$XCBEAUTIFY_DIR/xcbeautify" --version > /dev/null 2>&1; then
          echo "xcbeautify found in cache, skipping download"
        else
          echo "xcbeautify not found in cache, downloading..."
          mkdir -p "$XCBEAUTIFY_DIR"
          
          # Download the specified xcbeautify binary from GitHub releases
          # Using the user-specified version with universal macOS binary
          XCBEAUTIFY_VERSION="${{ inputs.xcbeautify-version }}"
          XCBEAUTIFY_URL="https://github.com/cpisciotta/xcbeautify/releases/download/${XCBEAUTIFY_VERSION}/xcbeautify-${XCBEAUTIFY_VERSION}-universal-apple-macosx.zip"
          
          # Download and extract the binary
          curl -L -o "$XCBEAUTIFY_DIR/xcbeautify.zip" "$XCBEAUTIFY_URL"
          cd "$XCBEAUTIFY_DIR"
          unzip -q xcbeautify.zip
          
          # The binary is in the release/xcbeautify directory after extraction
          # Move it to the root of our installation directory
          mv release/xcbeautify ./
          rmdir release
          
          # Clean up the zip file to save space
          rm xcbeautify.zip
          
          # Make the binary executable
          chmod +x xcbeautify
        fi
        
        # Verify the installation
        "$XCBEAUTIFY_DIR/xcbeautify" --version
        
        # Add to PATH for this step and subsequent steps
        echo "$XCBEAUTIFY_DIR" >> $GITHUB_PATH

    # Build Type Decision Logic:
    # The action chooses between two build approaches based on the 'type' parameter:
    #
    # 1. Xcode Builds (when 'type' is specified):
    #    - Uses xcodebuild with platform-specific SDK and destination
    #    - Enables simulator testing for iOS/watchOS/tvOS/visionOS
    #    - Leverages derived data caching for optimal performance
    #    - Required for Apple platform testing with specific simulators
    #
    # 2. SPM Builds (when 'type' is omitted):
    #    - Uses swift build/test commands directly
    #    - Cross-platform compatible (works on both macOS and Ubuntu)
    #    - Uses standard .build directory caching
    #    - Faster for packages without Apple platform dependencies
    #
    # This conditional logic allows the same action to handle both Swift Package Manager
    # builds and comprehensive Apple ecosystem testing seamlessly

    # Intelligent Caching Strategy 1: Xcode Derived Data (macOS + Apple Platform Builds)
    # Uses specialized irgaly/xcode-cache action optimized for Xcode derived data management.
    # This approach is significantly more efficient than generic actions/cache for Xcode builds
    # because it understands Xcode's derived data structure and selective caching needs.
    #
    # Cache Key Strategy:
    # - Primary: xcode-deriveddata-{OS}-{XcodeVersion}-{ResolvedHash}-{CommitSHA}
    # - Fallback: xcode-deriveddata-{OS}-{XcodeVersion}-{ResolvedHash}-
    #
    # Key Components Explained:
    # - runner.os: Ensures platform isolation (different derived data per OS)
    # - XCODE_NAME: Isolates builds between different Xcode versions (critical for compatibility)
    # - ResolvedHash: Either Package.resolved hash or 'no-resolved' (see detect-resolved step)
    # - github.sha: Provides exact build reproducibility (fallback allows partial matches)
    #
    # Performance Benefits:
    # - ~70-85% build time reduction on cache hits
    # - Preserves incremental compilation benefits
    # - Handles module dependency graphs efficiently
    # - Reduces redundant downloading of precompiled Swift modules
    - uses: irgaly/xcode-cache@v1
      if: steps.detect-os.outputs.os == 'macos' && inputs.type && steps.detect-resolved.outputs.use-resolved == 'true'
      with:
        key: xcode-deriveddata-${{ runner.os }}-${{ env.XCODE_NAME }}-${{ steps.detect-resolved.outputs.resolved-hash }}-${{ github.sha }}
        restore-keys: |
          xcode-deriveddata-${{ runner.os }}-${{ env.XCODE_NAME }}-${{ steps.detect-resolved.outputs.resolved-hash }}-
        deriveddata-directory: ${{ env.DERIVED_DATA_PATH }}
        swiftpm-package-resolved-file: |
          ${{ inputs.working-directory }}/Package.resolved

    # Xcode Derived Data Cache (Without Package.resolved)
    # Same as above but omits swiftpm-package-resolved-file parameter when Package.resolved
    # is not being used (either missing or skip-package-resolved=true)
    - uses: irgaly/xcode-cache@v1
      if: steps.detect-os.outputs.os == 'macos' && inputs.type && steps.detect-resolved.outputs.use-resolved == 'false'
      with:
        key: xcode-deriveddata-${{ runner.os }}-${{ env.XCODE_NAME }}-${{ steps.detect-resolved.outputs.resolved-hash }}-${{ github.sha }}
        restore-keys: |
          xcode-deriveddata-${{ runner.os }}-${{ env.XCODE_NAME }}-${{ steps.detect-resolved.outputs.resolved-hash }}-
        deriveddata-directory: ${{ env.DERIVED_DATA_PATH }}

    # Ubuntu specific steps
    - name: Get Swift and OS versions
      if: steps.detect-os.outputs.os == 'ubuntu'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        SWIFT_VERSION=$(swift --version | head -n 1 | cut -d ' ' -f 3)
        echo "SWIFT_VERSION=$SWIFT_VERSION" >> $GITHUB_ENV
        OS_VERSION=$(. /etc/os-release && echo $VERSION_CODENAME)
        echo "OS_VERSION=$OS_VERSION" >> $GITHUB_ENV

    # Windows specific steps
    - name: Get Swift version for Windows
      if: steps.detect-os.outputs.os == 'windows'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        SWIFT_VERSION=$(swift --version | head -n 1 | cut -d ' ' -f 3)
        echo "SWIFT_VERSION=$SWIFT_VERSION" >> $GITHUB_ENV
        # Get Windows version and build number for cache key using simple registry lookup
        # This provides better cache isolation based on Windows version and build
        # Examples: "Windows Server 2022" + "20348" -> "windows-server-2022-20348"
        WINDOWS_PRODUCT=$(powershell -Command "(Get-ItemProperty 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion').ProductName -replace ' ', '-'" | tr '[:upper:]' '[:lower:]')
        WINDOWS_BUILD=$(powershell -Command "(Get-ItemProperty 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion').CurrentBuild")
        WINDOWS_VERSION="${WINDOWS_PRODUCT}-${WINDOWS_BUILD}"
        echo "WINDOWS_VERSION=$WINDOWS_VERSION" >> $GITHUB_ENV

    # Intelligent Caching Overview:
    # This action implements four distinct caching strategies optimized for different build scenarios:
    #
    # Strategy 1: Xcode Derived Data Caching (macOS + Apple platforms)
    #   - Uses irgaly/xcode-cache for Xcode simulator builds
    #   - Caches derived data directory with build artifacts and module cache
    #   - Most efficient for iOS/watchOS/tvOS/visionOS/macOS testing
    #   - Achieves 70-85% build time reduction
    #
    # Strategy 2a: macOS SPM Caching (Cross-platform packages on macOS)
    #   - Uses actions/cache for .build directory
    #   - Simpler than derived data, focused on SPM artifacts
    #   - Optimal for packages without Apple platform dependencies
    #   - Achieves 60-75% build time reduction
    #
    # Strategy 2b: Ubuntu SPM Caching (Linux builds)
    #   - Uses actions/cache with comprehensive directory coverage
    #   - Includes .build, .swiftpm, and .cache directories
    #   - Handles Ubuntu-specific Swift toolchain artifacts
    #   - Achieves 65-80% build time reduction
    #
    # Strategy 2c: Windows SPM Caching (Windows builds)
    #   - Uses actions/cache with comprehensive directory coverage
    #   - Includes .build, .swiftpm, and .cache directories
    #   - Handles Windows-specific Swift toolchain artifacts
    #   - Achieves 65-80% build time reduction
    #
    # Cache Invalidation Triggers:
    # - Package.resolved changes (dependency updates)
    # - Swift/Xcode version changes (toolchain compatibility)
    # - OS version changes (ABI compatibility)
    # - Exact commit SHA ensures build reproducibility

    # Intelligent Caching Strategy 2: Swift Package Manager Builds
    # These caching steps use the standard actions/cache for SPM builds, which is optimal
    # for cross-platform Swift packages that don't require Apple platform simulators.

    # Intelligent Caching Strategy 2a: macOS SPM Cache (Cross-Platform Packages)
    # Used when building Swift packages on macOS without specific Apple platform targeting.
    # Focuses on .build directory which contains Swift Package Manager compilation artifacts.
    #
    # Cache Key Strategy:
    # - Pattern: spm-{OS}-{XcodeVersion}-{ResolvedHash}
    # - Xcode version isolation ensures Swift toolchain compatibility
    # - ResolvedHash: Either Package.resolved hash or 'no-resolved' (see detect-resolved step)
    # - Simpler than derived data caching since no platform-specific artifacts
    #
    # Performance: ~60-75% build time reduction for cross-platform packages
    - name: Cache swift package modules (macOS)
      if: steps.detect-os.outputs.os == 'macos' && !inputs.type
      uses: actions/cache@v4
      with:
        path: ${{ inputs.working-directory }}/.build
        key: spm-${{ runner.os }}-${{ env.XCODE_NAME }}-${{ steps.detect-resolved.outputs.resolved-hash }}
        restore-keys: |
          spm-${{ runner.os }}-${{ env.XCODE_NAME }}-

    # Intelligent Caching Strategy 2b: Ubuntu SPM Cache (Linux Builds)
    # Comprehensive caching for Ubuntu Swift builds covering all SPM directories.
    # Includes additional .swiftpm and .cache directories that Swift uses for metadata.
    #
    # Cache Key Strategy:
    # - Pattern: spm-{UbuntuVersion}-{SwiftVersion}-{ResolvedHash}
    # - OS version isolation (focal/jammy/noble) ensures ABI compatibility
    # - Swift version isolation prevents toolchain conflicts
    # - ResolvedHash: Either Package.resolved hash or 'no-resolved' (see detect-resolved step)
    # - No Xcode version since Ubuntu uses system Swift toolchain
    #
    # Cached Directories Explained:
    # - .build: Compiled Swift modules and intermediate build artifacts
    # - .swiftpm: Swift Package Manager metadata and configuration cache
    # - .cache: Local cache directory used by swift build --cache-path flag
    #
    # Performance: ~65-80% build time reduction, especially effective for large dependency trees
    - name: Cache swift package modules (Ubuntu)
      if: steps.detect-os.outputs.os == 'ubuntu'
      uses: actions/cache@v4
      with:
        path: |
          ${{ inputs.working-directory }}/.build
          ${{ inputs.working-directory }}/.swiftpm
          ${{ inputs.working-directory }}/.cache
        key: spm-${{ env.OS_VERSION }}-${{ env.SWIFT_VERSION }}-${{ steps.detect-resolved.outputs.resolved-hash }}

    # Intelligent Caching Strategy 2c: Windows SPM Cache (Windows Builds)
    # Comprehensive caching for Windows Swift builds covering all SPM directories.
    # Similar to Ubuntu but with Windows-specific Swift toolchain considerations.
    #
    # Cache Key Strategy:
    # - Pattern: spm-windows-{WindowsProductNameSlug}-{BuildNumber}-{SwiftVersion}-{ResolvedHash}
    # - Windows version and build isolation ensures toolchain compatibility
    # - Swift version isolation prevents conflicts between different Windows Swift builds
    # - ResolvedHash: Either Package.resolved hash or 'no-resolved' (see detect-resolved step)
    # - Uses Swift version from installed Windows toolchain
    # - Uses slugified Windows product name + build number (e.g., "windows-server-2022-20348") for proper cache isolation
    #
    # Cached Directories Explained:
    # - .build: Compiled Swift modules and intermediate build artifacts
    # - .swiftpm: Swift Package Manager metadata and configuration cache
    # - .cache: Local cache directory used by swift build --cache-path flag
    #
    # Performance: ~65-80% build time reduction for Windows Swift builds
    - name: Cache swift package modules (Windows)
      if: steps.detect-os.outputs.os == 'windows'
      uses: actions/cache@v4
      with:
        path: |
          ${{ inputs.working-directory }}/.build
          ${{ inputs.working-directory }}/.swiftpm
          ${{ inputs.working-directory }}/.cache
        key: spm-${{ env.WINDOWS_VERSION }}-${{ env.SWIFT_VERSION }}-${{ steps.detect-resolved.outputs.resolved-hash }}

    # Build and Test Execution: Two-Path Strategy
    # The action implements a dual-path build strategy to handle both cross-platform Swift packages
    # and Apple platform-specific testing requirements. This approach maximizes compatibility while
    # providing optimized performance for each build scenario.
    #
    # Path Selection Logic:
    # 1. SPM Build Path: Used when 'type' parameter is omitted
    #    - Cross-platform compatible (Ubuntu + macOS)
    #    - Uses swift build/test commands directly
    #    - Faster for packages without Apple platform dependencies
    #    - Optimal for open-source Swift packages
    #
    # 2. Xcode Build Path: Used when 'type' parameter is specified
    #    - macOS-only (requires Xcode toolchain)
    #    - Uses xcodebuild for platform-specific testing
    #    - Required for iOS/watchOS/tvOS/visionOS simulator testing
    #    - Enables comprehensive Apple ecosystem validation

    # SPM Build and Test Execution (Cross-Platform Swift Packages)
    # This step handles standard Swift Package Manager builds for packages that work across
    # multiple platforms without requiring Apple platform simulators or specific Xcode versions.
    #
    # Command Breakdown:
    # - swift build --build-tests: Compiles both the package and its test targets
    # - swift test --enable-code-coverage: Runs tests with coverage collection
    # - --cache-path .cache: Uses local cache directory for build artifacts (improves performance)
    # - --force-resolved-versions: Enforces strict dependency pinning (omitted only when skip-package-resolved=true)
    #
    # Dependency Resolution:
    # - When skip-package-resolved='false': Always uses --force-resolved-versions (strict mode)
    # - When skip-package-resolved='true': Omits flag to allow floating dependency versions
    #
    # Platform Compatibility:
    # - Ubuntu: Uses system Swift toolchain (5.9-6.2 depending on runner)
    # - macOS: Uses Xcode-bundled Swift when no specific Apple platform is targeted
    # - Windows: Uses installed Swift toolchain
    #
    # Performance Optimizations:
    # - Build artifacts cached via .build directory (60-80% time reduction)
    # - Force-resolved-versions prevents dependency resolution inconsistencies
    # - Cache-path flag enables local build artifact reuse
    - name: Build and Test
      if: (steps.detect-os.outputs.os == 'macos' && !inputs.type) || steps.detect-os.outputs.os == 'ubuntu' || steps.detect-os.outputs.os == 'windows'
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        # Build resolved versions flag conditionally
        # Only skip the flag when user explicitly requested skip-package-resolved=true
        if [[ "${{ inputs.skip-package-resolved }}" == "true" ]]; then
          RESOLVED_FLAG=""
        else
          RESOLVED_FLAG="--force-resolved-versions"
        fi

        swift build --build-tests --cache-path .cache $RESOLVED_FLAG
        swift test --enable-code-coverage --cache-path .cache $RESOLVED_FLAG

    # Xcode Build and Test Execution (Apple Platform Testing)
    # This step handles Xcode-based builds for testing Swift packages on Apple platforms
    # (iOS, watchOS, tvOS, visionOS, macOS) using simulators or native macOS execution.
    #
    # Build Strategy Decision:
    # - macOS builds: Use native platform testing (no simulator required)
    # - iOS/watchOS/tvOS/visionOS: Use simulator-based testing with specific device/OS combinations
    #
    # Command Parameters Explained:
    # - -scheme: Specifies which build scheme to use (must match Package.swift or .xcodeproj)
    # - -sdk: Platform SDK (iphonesimulator, watchsimulator, appletvsimulator, xrsimulator, macosx)
    # - -destination: Target platform and device configuration for testing
    # - -enableCodeCoverage: Collects code coverage metrics during test execution
    # - -derivedDataPath: Uses optimized derived data location for caching performance
    #
    # Destination String Construction:
    # - macOS: 'platform=macOS' (native execution, no simulator)
    # - Other platforms: 'platform={PLATFORM},name={deviceName},OS={osVersion}'
    #   Examples: 'platform=iOS Simulator,name=iPhone 15,OS=17.0'
    #             'platform=watchOS Simulator,name=Apple Watch Series 9 (45mm),OS=10.0'
    #
    # Performance Benefits:
    # - Derived data caching provides 70-85% build time reduction
    # - Platform-specific optimizations leverage Xcode's incremental compilation
    # - Simulator reuse reduces platform initialization overhead
    - name: Build and Test (macOS Device)
      if: steps.detect-os.outputs.os == 'macos' && inputs.type
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        # Fix for iOS simulator connection issue (https://github.com/actions/runner-images/issues/12862)
        # Establish simulator connection before running xcodebuild
        xcrun simctl list > /dev/null
        
        # Build destination string based on platform type
        if [ "${{ inputs.type }}" = "macos" ]; then
          DESTINATION="platform=macOS"
        else
          DESTINATION="platform=${{ env.PLATFORM }},name=${{ inputs.deviceName }},OS=${{ inputs.osVersion }}"
        fi
        
        # Build xcodebuild command
        XCODEBUILD_CMD="xcodebuild test \
          -scheme ${{ inputs.scheme }} \
          -sdk ${{ env.SDK }} \
          -destination \"$DESTINATION\" \
          -enableCodeCoverage YES \
          -derivedDataPath ${{ env.DERIVED_DATA_PATH }}"
        
        # Execute with or without xcbeautify
        if [ "${{ inputs.use-xcbeautify }}" = "true" ]; then
          # Set up unbuffered I/O for better xcbeautify output
          export NSUnbufferedIO=YES
          
          # Build xcbeautify command
          if [ -n "${{ inputs.xcbeautify-renderer }}" ] && [ "${{ inputs.xcbeautify-renderer }}" != "default" ]; then
            XCBEAUTIFY_CMD="xcbeautify --renderer ${{ inputs.xcbeautify-renderer }}"
          else
            XCBEAUTIFY_CMD="xcbeautify"
          fi
          
          # Execute with xcbeautify and proper pipe failure handling
          # Use set -o pipefail to ensure xcodebuild failures are not masked by xcbeautify success
          set -o pipefail
          eval "$XCODEBUILD_CMD 2>&1 | $XCBEAUTIFY_CMD"
          # Capture exit code to ensure build failures are properly reported
          BUILD_EXIT_CODE=$?
          if [ $BUILD_EXIT_CODE -ne 0 ]; then
            echo "Build failed with exit code: $BUILD_EXIT_CODE" >&2
            exit $BUILD_EXIT_CODE
          fi
        else
          # Execute without xcbeautify
          eval "$XCODEBUILD_CMD"
        fi
